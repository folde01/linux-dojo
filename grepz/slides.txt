Example: building grepz, a handy search tool

This example will show a way to build grepz, a shell script I wrote recently for helping me when writing Terraform code. grepz takes an arbitrary number of arguments as strings, and looks recursively under the current directory for files that contain all those strings.

For each such file it finds, it will show the filename, followed by all the matching lines with their respective line numbers.

Let's try to do this in a semi-test driven development way. First we'll make a few text files to work with.

$ mkdir testfiles
$ cd testfiles

$ echo UK > countries.txt
$ echo USA >> countries.txt
$ echo France >> countries.txt

$ cat countries.txt
UK
USA
France

$ cat << EOF > cities.txt
London
New York
Cardiff
York
Paris
EOF

The command above is called a 'heredoc' - https://www.gnu.org/software/bash/manual/html_node/Redirections.html is all about this and other very useful forms of 'redirection' of input and output in bash, like > and >> above. 
 
$ cat cities.txt 
London
New York
Cardiff
York
Paris

To make sure we're looking for files recursively, let's make a sub-folder with a file in it.

$ mkdir country-info

$ cat << EOF > country-info/capitals.txt
London, UK
Washington DC, USA
Paris, France
EOF

$ cat country-info/capitals.txt
London, UK
Washington DC, USA
Paris, France

Let's make a few test cases showing how we want grepz to behave:

Case 1 - search for one string

$ grepz UK

## ./country-info/capitals.txt
1:London, UK

## ./countries.txt
1:UK

Case 2 - search for two strings

$ grepz UK USA

## ./country-info/capitals.txt
- UK -
1:London, UK
- USA -
2:Washington DC, USA

## ./countries.txt
- UK -
1:UK
- USA -
2:USA

Case 3 - search for three strings

$ grepz UK USA France

## ./country-info/capitals.txt
- UK -
1:London, UK
- USA -
2:Washington DC, USA
- France -
3:Paris, France

## ./countries.txt
- UK -
1:UK
- USA -
2:USA
- France -
3:France



So how to make it do all that? Let's take it in steps.

----------------

Step 1: search for one string 

We'll use "UK" as our search string, as in Case 1.

$ grep UK countries.txt 
UK

$ grep UK *
countries.txt:UK
grep: country-info: Is a directory

The * just expands to what's in the current directory. It's not recursive, but grep -R is.

$ grep -R UK
country-info/capitals.txt:London, UK
countries.txt:UK

$ grep -R -n UK
country-info/capitals.txt:1:London, UK
countries.txt:1:UK

That gives us all the info we need, minus the formatting, but let's worry about that later.


----------------


Step 2: search for two strings, as in Case 2.

This is what we want:

$ grepz UK USA

## ./country-info/capitals.txt
- UK -
1:London, UK
- USA -
2:Washington DC, USA

## ./countries.txt
- UK -
1:UK
- USA -
2:USA


We can get part way there by getting a list of the files that contain UK and then searching each one for USA.

$ grep -R UK
country-info/capitals.txt:London, UK
countries.txt:UK

$ grep -R -l UK
country-info/capitals.txt
countries.txt

$ grep -R -l UK | while read filename; do echo hello; done
hello
hello

Here we use 'read', which is taking a line of text from the pipe and putting it in the variable $filename. 'while' loops over the values of $filename until the pipe runs dry.

$ grep -R -l UK | while read filename; do echo $filename; done
country-info/capitals.txt
countries.txt

$ grep -R -l UK | while read filename; do grep USA $filename; done
Washington DC, USA
USA

$ grep -R -l UK | while read filename; do grep -l USA $filename; done
country-info/capitals.txt
countries.txt


But let's say we want to make sure we don't match on 'US', only 'USA'. And not 'K', but 'UK'.


$ grep -R -l UK | while read filename; do grep -l US $filename; done
country-info/capitals.txt
countries.txt

$ grep -R -l UK | while read filename; do grep -l -w US $filename; done

$ grep -R -l UK | while read filename; do grep -l -w USA $filename; done
country-info/capitals.txt
countries.txt

$ grep -w -R -l UK | while read filename; do grep -l -w USA $filename; done
country-info/capitals.txt
countries.txt

$ grep -w -R -l K | while read filename; do grep -l -w USA $filename; done
$ 


Ok, great, we now have a list of files that have contain both UK and USA.


------------------


Step 3: Search for three strings


Recall what we need: 

Case 3 - three strings

$ grepz UK USA France

## ./country-info/capitals.txt
- UK -
1:London, UK
- USA -
2:Washington DC, USA
- France -
3:Paris, France

## ./countries.txt
- UK -
1:UK
- USA -
2:USA
- France -
3:France


Let's aim first for the list of files we need. We could just add another pipe on the end like this:

$ grep -w -R -l UK | while read filename; do grep -w -l USA $filename | while read filename2; do grep -w -l France $filename2; done; done

Making that easier to read:

$ grep -w -R -l UK | while read filename; do
>   grep -w -l USA $filename | while read filename2; do
>     grep -w -l France $filename2;
>   done
> done
country-info/capitals.txt
countries.txt

Recall from above that the output of the second grep (for USA) is a list of filenames containing both UK and USA. We're piping that to another 'while read variable' as above. That works fine for three, but what about ten? And arbitrary strings as opposed to hard-coded ones?


------------------


Step 4: Search for n strings 


Again, recall Case 3:

$ grepz UK USA France

## ./country-info/capitals.txt
- UK -
1:London, UK
- USA -
2:Washington DC, USA
- France -
3:Paris, France

## ./countries.txt
- UK -
1:UK
- USA -
2:USA
- France -
3:France

Let's put our strings in an array, as we can make our array arbitrarily long.

$ strings=("UK" "USA" "France")

Now let's get the files matching the first element.

$ first_string="${strings[0]}"
$ echo $first_string 
UK

$ files=$(grep -l -R -w "$first_string")

$ echo "$files"
./country-info/capitals.txt
./countries.txt

If we then loop over the rest of the strings, searching for each one in our remaining list of files, we can change $files to reflect the change as we go. 

$ rest_of_strings="${strings[@]:1}"
$ echo "$rest_of_strings"
USA France

More on array slicing: https://stackoverflow.com/questions/1335815/how-to-slice-an-array-in-bash 

Now build the loop:

$ for string in "$rest_of_strings"
> do
>   echo "$string"
> done
USA France

That's not what we wanted. Bash is seeing "$rest_of_strings" as one word. echoing it first splits it up before 'for' starts using it.

$ for string in `echo "$rest_of_strings"`
> do
>   echo "$string"
> done
USA
France

Now make the loop change the value of files.

$ for string in `echo "$rest_of_strings"`
> do
>   files=$(echo "$files" | while read filename
>     do
>       grep -w -l "$string" $filename
>     done)
> done

And a sanity check shows we still have the list of files we want:

$ echo "$files"
country-info/capitals.txt
countries.txt


------------------


Step 5: Show the matches for each file, with line numbers and formatting.


We now know that $files is all the files containing all the strings in $strings, so we can make a nested loop to produce our output.

$ for filename in `echo "$files"`
> do
>   echo "## ${filename}"
>   for string in "${strings[@]}"
>   do
>     echo "- $string -"
>     grep -n --colour "$string" "$filename"
>   done
>   echo
> done

## country-info/capitals.txt
- UK -
1:London, UK
- USA -
2:Washington DC, USA
- France -
3:Paris, France

## countries.txt
- UK -
1:UK
- USA -
2:USA
- France -
3:France

We don't need the '-- String --' lines if we only have one string, so let's put all of this in a file, build the array from the command line arguments, and add a flag for when we have multiple search strings.

$ cat grepz
#!/bin/bash

strings=("$@")

if [ ${#strings[@]} -eq 1 ]; then
  many_strings=1
fi

first_string="${strings[0]}"
files=$(grep -l -R -w "$first_string")

for string in `echo "$rest_of_strings"`
do
  files=$(echo "$files" | while read filename
    do
      grep -w -l "$string" $filename
    done)
done

echo

for filename in `echo "$files"`
do
  echo "## ${filename}"
  for string in "${strings[@]}"
  do
    echo "- $string -"
    grep -n --colour "$string" "$filename"
  done
  echo
done

$



Make it executable and put it somewhere in your $PATH so you can run it.

$ chmod +x grepz 
$ sudo cp grepz /usr/local/bin

We can double check our that we still pass our three test cases:

$ grepz UK
$ grepz UK USA
$ grepz UK USA France


------------------

Exercise:

Below are some other test cases grepz should be able to pass at this stage. Make sure it does, and then change Case 7 so that it produces a match on 'Yor'. If you still have time, make a new test case for "Yor", "York" and "New York" (how it should behave is up to you) and make grepz pass it.

Case 4 

$ grepz York

## ./cities.txt 
2:New York
4:York

Case 5

$ grepz "New York"

## ./cities.txt 
2:New York

Case 6

$ grepz York "New York"

## ./cities.txt 
- York -
2:New York
4:York
- New York -
2:New York

Case 7

$ grepz Yor

[no results]

Case 8

$ grepz New York

## ./cities.txt 
- New -
2:New York
- York -
2:New York
4:York


